clc; clear all; close all##   ___                  _        __              ___                   ____   __  ___   ____ ____  ___ ##  / _ \  ____ ___      (_) ___  / /_ ___        |_  |      ____       / __/  /  |/  /  / __//_  / / _ \## / ___/ / __// _ \    / / / -_)/ __// _ \      / __/      /___/      / _/   / /|_/ /  /__ \  / / / // /##/_/    /_/   \___/ __/ /  \__/ \__/ \___/     /____/                /___/  /_/  /_/  /____/ /_/  \___/ ##                  |___/                                                                                #ASSINAM ESTE CÓDIGO:#NATAN SILVA SILVEIRA#RAFAEL AUGUSTO BRAGA COTA#PAULO YOSHIO KUGA#Utilização do método implícito p/ solução da eq diferencial.#############################################################################################################################                                                         CASOS:#Qual é o seu caso?#convec - convecção na borda#timevar - temperatura variante na borda#fixed - temperaturas fixas nas bordas#infinite - parede infinitacaso = "infinite" #########################################################################################################################################################################################################################################################                                           DISTRIBUIÇÃO INICIAL DE TEMPERATURA#Qual distribuição você deseja?#cte - distribuição constante de temperatura#sin - distribuição senoidalinicial = "sin" #########################################################################################################################################################################################################################################################------------------------------------------CONDIÇÕES DO PROBLEMA------------------------------------------------------------#Consulte um adulto mais experiente antes de mexer nesta parte.L = 100; #[m] tamanho total da parede (PARA CASO PAREDE INFINITA USE UM NUMERO GRANDE ex: 3000)switch caso case "convec"   L = L/2 #o caso é simétrico! basta apresentar um único ladoendswitch  ns = 101; #numero de pontos de espaço (caso: convec -> vai discretizar meia parede)tempo = 85000; #[s] quantidade de tempont = 20; #numero de pontos de tempoh = 100; %coeficiente de convecção do ar [J/(s*K*m^2)]k = 401; %coeficiente de condução do cobre [J/(s*m*K)]rho = 8960; %massa especí­fica do cobre [kg/m^3] cp= 376.56; %calor específico do cobre[J/(Kg*K)]###########################################################################################################################x = linspace(0,L,ns)'; #MALHA ESPACIALt = linspace(0,tempo,nt)'; #MALHA TEMPORAL############################################################################################################################switch inicial  case "cte"    T0 = 500 #temperatura inicial    T = T0*ones(ns,1); #temperatura constante inicial no dominio  case "sin"    m = 5 #fase do ruido    T1 = 1000 #temperatura 1    T0 = 500  #temperatura 2    T = sin(m*x) + T1 + (T0-T1)*(x/L);endswitchswitch caso  case "convec"    Tinf = 300 #temepratura do fluido que envolve a parede          case "fixed"    Tp1 = 300 #temperatura esquerda    Tp2 = 300 #temperatura direita    T(1) = Tp1;    T(end) = Tp2;          case "infinite"    Ti = T0 #temperatura no infinito    Tinf = 600 #temepratura infinita na convecção      case "timevar"      #caso variante no tempo      #coloque as condições de temperatura variantes no tempo      T0 = 300;      Tb1 = 10;      Tb2 = 10;      #CUIDADO: ESTE 0 PRECISA APARECER EM VIRTUDE DA FORMA COM QUE O ALGORITIMO FOI ESCRITO      #Justificativa: é mais conveniente adicionar um 0 no array do que escrevermos demasiados if's para execução do código.      Tp1 = [T0+Tb1*sin(t); 0]; #[T0+(t/tempo)*Tb1; 0]; #+exp(-t/(nt-1))*Tb1;      Tp2 = [T0+Tb1*sin(t); 0]; #[T0+(t/tempo)*Tb2; 0]; #+exp(-t/(nt-1))*Tb2;             otherwiseendswitch##########################################################################################################################################################################  ##   _  __                                  __                   __          _               __##  / |/ / ___ _ ___        __ _  __ __ ___/ / ___       ___ _  / /  ___ _  (_) __ __ ___   / /## /    / / _ `// _ \      /  ' \/ // // _  / / -_)     / _ `/ / _ \/ _ `/ / /  \ \ // _ \ /_/ ##/_/|_/  \_,_/ \___/     /_/_/_/\_,_/ \_,_/  \__/      \_,_/ /_.__/\_,_/ /_/  /_\_\ \___/(_)  #### Se você não for implementar nenhum caso.                                                                                                                                                               ############################################################################################################################################################################                                                                                                                                            alpha = k/(rho*cp); %indice de difusividade termicadt = tempo/(nt-1) ; #tamanho do passo do tempodx = L/(ns-1) ; #tamanho do passo do espaçoFo = alpha*dt/dx**2; #numero de fourierBil = h*dx/k; #biot local (serve p/ reduzir o numero de termos dentro da convecção)#DISCRETIZAÇÃO DA EQ DIFFk1 = -Fo; k2 = (1+2*Fo); k3 = -Fo;#SE A MATRIZ É MUITO GRANDE, PODEMOS DECLARÁ-LA ESPARSA E TORNAR MAIS RÁPIDA A EXECUÇÃOif ns**2 >= 625  K = sparse(ns,ns); else  K = zeros(ns);endif#gl -> graus de liberdade - numero de pontos a serem resolvidos#Ts -> temperatura que será switch caso  case "convec"    K(1,1:2) = [(1+Fo) -Fo]; #condição adiabática no meio    K(end,end-1:end) = [-Fo (1+Fo*(1+Bil))]; #convecção    gl = [1:ns];     Ts = T;     Ts(end) = Ts(end) + Fo*Bil*Tinf;       case "fixed"    gl = [2:ns-1];    Ts = T(gl);    Ts(1) = Ts(1) + Fo*Tp1;     Ts(end) = Ts(end) + Fo*Tp2;      case "infinite"    K(1,1:2) = [(1+Fo*(1+Bil)) -Fo]; #convecção na entrada    gl = [1:ns-1];    Ts = T(gl);    Ts(1) = Ts(1)+ Fo*Bil*Tinf;    Ts(end) = Ts(end) + Fo*Ti; #temperatura fixa na saída  case "timevar"    gl = [2:ns-1];    Ts = T(gl);    Ts(1) = Ts(1) + Fo*Tp1(2); #valor inicial p/ distribuição no tempo - nós já conhecemos o valor n+1 do primeiro ponto    Ts(end) = Ts(end) + Fo*Tp2(2); #idem            otherwiseendswitch#geração da matriz de coeficientesfor i=2:ns-1	K(i, i-1) = k1;	K(i, i) = k2;	K(i, i+1) = k3;end#determinação da matriz que acompanha resoluçãoKs = K(gl, gl);#o primeiro tempo já passou com ts#loop de temposavem = []; #array aberto para salvar  os resultados#loop de execução da matriztic; #inicio da contagem do tempofor i = 2:nt  Ts = Ks\Ts; 	savem = [savem; Ts'];  switch caso    case "fixed"      Ts(1) = Ts(1) + Fo*Tp1;      Ts(end) = Ts(end) + Fo*Tp2;    case "convec"      Ts(end) = Ts(end) + Fo*Bil*Tinf;    case "infinite"      Ts(end) = Ts(end) + Fo*Ti;      Ts(1) = Ts(1)+ Fo*Bil*Tinf;    case "timevar"    #note que diferente dos outros, aqui temos o indice do tempo variando o array    #aliás, é importante notar para que este i+1 não acesse um endereço fora da memória, colocamos um 0 no fim do array      Ts(1) = Ts(1) + Fo*Tp1(i+1);       Ts(end) = Ts(end) + Fo*Tp2(i+1);  endswitch
endfortempo_de_execucao = toc #tempo que levou para resolver o sistema#execução da correção da matriz que salva os resultadosswitch caso  case "fixed"    savem = [T'; Tp1*ones(nt-1,1) savem Tp2*ones(nt-1,1)];  case "infinite"    savem = [T'; savem Ti*ones(nt-1,1)];  case "timevar"    savem = [T'; Tp1(2:end-1) savem Tp2(2:end-1)];   otherwise    savem = [T'; savem];endswitch#########################################################################################################funcoes para gerar analiticas e aproximaçãofunction ksi =ksisol(Bi,n)      #olha, honestamente, essa parte aqui eu fiz no desmos e fiz estimativas      #agente secreto - paulo y. kuga  if Bi <= 4    f = @(x) cosh(pi*x/2) -1 - Bi;    ini = fsolve(f,1);  else     ini = 1.3;  endif  x = [ini (1:1:n)*pi]';  f = @(x) x*tan(x) - Bi;  ksi = []  for i=1:rows(x)    ksi(i,1) = fsolve(f,x(i));  endforendfunctionfunction animaplot(savem,x,nt)  plot(x, savem(1,:))  for i=2:nt-1      plot(x,savem(i,:)); #plota      hold on;       pause(.001) #aguarda a sincronização da CPU      clf  endfor  plot(x,savem(end,:));endfunction#######################################################################################################analise de erro para soluções conhecidasswitch caso  case "convec"    x_p=x'/L;    Bi2=h*L/(k);    Fo2 = alpha*t/L^2;    n = 10; #tem uma hora q começa a ficar    ksi = ksisol(Bi2,n);    theta = zeros(nt,ns);    for i=1:n      z = ksi(i);       Cn=(4*sin(z))/(2*z + sin(2*z));      theta = theta + Cn*exp((-z**2)*Fo2)*cos(z*x_p);    endfor    Ttot =Tinf + (T0-Tinf)*theta;    erro = norm(Ttot-savem)/norm(Ttot) #note que o erro é aceitável (e ainda nem é a solução exata, é apenas a aproximada)  case "infinite"    Ttot=zeros(nt,ns);    Theta=zeros(1,ns);    for j=1:nt      for i=1:ns        Theta(i)=erfc(x(i)/(2*((alpha*t(j))^0.5)))-(exp(h*x(i)/k + (h^2)*alpha*t(j)/(k^2)))*(erfc(x(i)/(2*((alpha*t(j))^0.5)) + h*((alpha*t(j))^0.5)/k));      end      Ttot(j,:)=Theta*(Tinf-T0) + T0;    end    Ttot(1,1) = T0;    erro = norm(Ttot-savem)/norm(Ttot)endswitch#ANIMACAOanimaplot(savem,x,nt)